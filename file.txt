`define SIGN_BIT 63
`define MSB 62
`define exponent 61
`define count 52
module cmp(
	input [63:0] dataA,
	input [63:0] dataB,
	output reg greater,
	output reg smaller,
	output reg invalid,
	output reg equal);

	always @(dataA or dataB)begin
			specialNum(dataA,smaller,equal,greater,invalid);		
		if(dataA[`SIGN_BIT] > dataB[`SIGN_BIT] && invalid==0)begin
			smaller = 1;		
			equal = 0;
			greater = 0;
		end else if(dataA[`SIGN_BIT] < dataB[`SIGN_BIT] && invalid==0) begin
			smaller = 0;
			equal = 0;
			greater = 1;
		end else begin
			if(dataA[`SIGN_BIT] == 0 && invalid==0)begin
				getCmp(dataA,dataB,smaller,equal,greater,invalid);
			end else begin
				getCmp(dataB,dataA,smaller,equal,greater,invalid);
			end
		end
	end
	
	task getCmp(input [63:0] dataA,
					input [63:0] dataB,
					output smaller,
					output equal,
					output greater,
					output invalid);
		integer i;
		begin
			for(i = `MSB; i >= 0; i = i - 1)begin
				if(dataA[i] > dataB[i])begin
					greater = 1;
					smaller = 0;
					equal = 0;
					invalid = 0; 
					i = -1;				
end else if(dataA[i] < dataB[i])begin
					smaller = 1;
					greater =0;
					equal = 0;
					invalid = 0; 
					i = -1;
				end else if(dataA[i] == dataB[i]) begin
					equal = 1;
					greater = 0;
					smaller = 0;
					invalid = 0; 
				end
			end
		end		
	endtask
	
	task specialNum(input[63:0] dataA,
					output smaller,
					output equal,
					output greater,
					output invalid);
		begin if ((dataA[63:52] == 1 && dataA[51:0] == 0) || (dataA[63] == 0 && dataA[62:52]==1 && dataA[51:0] == 0) ||( dataA[62:0] == 0) )
				invalid = 1;
				smaller = 0;
				greater =0;
				equal =0;
		end		
	endtask	
endmodule